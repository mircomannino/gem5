From 6ac391622e415b22bdececa9590f42a13cd89564 Mon Sep 17 00:00:00 2001
From: Mirco Mannino <mircomannino1997@gmail.com>
Date: Sun, 8 Oct 2023 01:10:10 +0200
Subject: [PATCH] riscv: Add Sv39 page walker

---
 README.md                                     | 120 +++---------
 .../example_RAPIDO24/riscv_demo_board_se.py   | 142 ++++++++++++++
 src/arch/riscv/pagetable.hh                   |  78 ++++++++
 src/arch/riscv/pagetable_walker.cc            |   5 +
 src/arch/riscv/process.cc                     |  41 +++-
 src/arch/riscv/tlb.cc                         |  47 ++---
 src/arch/riscv/tlb.hh                         |   1 +
 src/base/loader/elf_object.cc                 |   4 +-
 src/base/loader/memory_image.cc               |   2 +-
 src/base/loader/memory_image.hh               |  13 +-
 src/mem/multi_level_page_table.hh             |   7 +-
 src/mem/page_table.cc                         |   2 +-
 src/mem/page_table.hh                         |   2 +-
 src/mem/port_proxy.hh                         |   6 +-
 src/mem/se_translating_port_proxy.cc          |  10 +-
 src/mem/translating_port_proxy.cc             |   6 +-
 src/mem/translating_port_proxy.hh             |   3 +-
 src/python/SConscript                         |   3 +
 .../components/boards/se_binary_workload.py   |   3 +
 ...e_l1_private_l2_cache_no_ptwc_hierarchy.py | 177 ++++++++++++++++++
 src/sim/process.cc                            |   4 +-
 src/sim/process.hh                            |   2 +-
 22 files changed, 535 insertions(+), 143 deletions(-)
 create mode 100644 configs/example_RAPIDO24/riscv_demo_board_se.py
 create mode 100644 src/python/gem5/components/cachehierarchies/classic/private_l1_private_l2_cache_no_ptwc_hierarchy.py

diff --git a/README.md b/README.md
index bd6db2fbd7..f6340d5202 100644
--- a/README.md
+++ b/README.md
@@ -1,90 +1,30 @@
-# The gem5 Simulator
-
-This is the repository for the gem5 simulator. It contains the full source code
-for the simulator and all tests and regressions.
-
-The gem5 simulator is a modular platform for computer-system architecture
-research, encompassing system-level architecture as well as processor
-microarchitecture. It is primarily used to evaluate new hardware designs,
-system software changes, and compile-time and run-time system optimizations.
-
-The main website can be found at <http://www.gem5.org>.
-
-## Getting started
-
-A good starting point is <http://www.gem5.org/about>, and for
-more information about building the simulator and getting started
-please see <http://www.gem5.org/documentation> and
-<http://www.gem5.org/documentation/learning_gem5/introduction>.
-
-## Building gem5
-
-To build gem5, you will need the following software: g++ or clang,
-Python (gem5 links in the Python interpreter), SCons, zlib, m4, and lastly
-protobuf if you want trace capture and playback support. Please see
-<http://www.gem5.org/documentation/general_docs/building> for more details
-concerning the minimum versions of these tools.
-
-Once you have all dependencies resolved, execute
-`scons build/ALL/gem5.opt` to build an optimized version of the gem5 binary
-(`gem5.opt`) containing all gem5 ISAs. If you only wish to compile gem5 to
-include a single ISA, you can replace `ALL` with the name of the ISA. Valid
-options include `ARM`, `NULL`, `MIPS`, `POWER`, `SPARC`, and `X86` The complete
-list of options can be found in the build_opts directory.
-
-See https://www.gem5.org/documentation/general_docs/building for more
-information on building gem5.
-
-## The Source Tree
-
-The main source tree includes these subdirectories:
-
-* build_opts: pre-made default configurations for gem5
-* build_tools: tools used internally by gem5's build process.
-* configs: example simulation configuration scripts
-* ext: less-common external packages needed to build gem5
-* include: include files for use in other programs
-* site_scons: modular components of the build system
-* src: source code of the gem5 simulator. The C++ source, Python wrappers, and Python standard library are found in this directory.
-* system: source for some optional system software for simulated systems
-* tests: regression tests
-* util: useful utility programs and files
-
-## gem5 Resources
-
-To run full-system simulations, you may need compiled system firmware, kernel
-binaries and one or more disk images, depending on gem5's configuration and
-what type of workload you're trying to run. Many of these resources can be
-obtained from <https://resources.gem5.org>.
-
-More information on gem5 Resources can be found at
-<https://www.gem5.org/documentation/general_docs/gem5_resources/>.
-
-## Getting Help, Reporting bugs, and Requesting Features
-
-We provide a variety of channels for users and developers to get help, report
-bugs, requests features, or engage in community discussions. Below
-are a few of the most common we recommend using.
-
-* **GitHub Discussions**: A GitHub Discussions page. This can be used to start
-discussions or ask questions. Available at
-<https://github.com/orgs/gem5/discussions>.
-* **GitHub Issues**: A GitHub Issues page for reporting bugs or requesting
-features. Available at <https://github.com/gem5/gem5/issues>.
-* **Jira Issue Tracker**: A Jira Issue Tracker for reporting bugs or requesting
-features. Available at <https://gem5.atlassian.net/>.
-* **Slack**: A Slack server with a variety of channels for the gem5 community
-to engage in a variety of discussions. Please visit
-<https://www.gem5.org/join-slack> to join.
-* **gem5-users@gem5.org**: A mailing list for users of gem5 to ask questions
-or start discussions. To join the mailing list please visit
-<https://www.gem5.org/mailing_lists>.
-* **gem5-dev@gem5.org**: A mailing list for developers of gem5 to ask questions
-or start discussions. To join the mailing list please visit
-<https://www.gem5.org/mailing_lists>.
-
-## Contributing to gem5
-
-We hope you enjoy using gem5. When appropriate we advise charing your
-contributions to the project. <https://www.gem5.org/contributing> can help you
-get started. Additional information can be found in the CONTRIBUTING.md file.
+# Integration of Page Table Walk in gem5 SE mode
+This branch enable the use of RISC-V page table walker in SE mode.
+
+## Differences
+All the differences, compared to gem5 v23.0.1.0, are shown in ```gem5.diff``` file.
+
+## Usage
+The configuration file includes additional options:
+```bash
+  --workload WORKLOAD  Path of the binary to run
+  --options OPTIONS    Options of the binary
+  --use-arch-pt        Enable the use of page table in SE mode Default: False
+  --dtb-size DTB_SIZE  Number of data TLB entries. Default: 64
+  --itb-size ITB_SIZE  Number of data TLB entries. Default: 64
+```
+The most important option is ```--use-arch-pt``` that enables the use of the page table walk in gem5 SE.
+
+An example of configuration script can be found in ```configs/example_RAPIDO24/riscv_demo_board.py```
+
+## Example
+The following command can be used to run a simulation with the demo board:
+```
+build/RISCV/gem5.opt \
+    configs/example_RAPIDO24/riscv_demo_board_se.py \
+    --workload <path/to/your/binary> \
+    --options <options of your binary> \
+    --use-arch-pt \
+    --dtlb-size 1024 \
+    --itlb-size 1024
+```
\ No newline at end of file
diff --git a/configs/example_RAPIDO24/riscv_demo_board_se.py b/configs/example_RAPIDO24/riscv_demo_board_se.py
new file mode 100644
index 0000000000..591b786b64
--- /dev/null
+++ b/configs/example_RAPIDO24/riscv_demo_board_se.py
@@ -0,0 +1,142 @@
+# Copyright (c) 2023 University of Siena
+# Copyright (c) 2022 The Regents of the University of California
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+"""
+This gem5 configuation script runs a binary on the
+RISCVMatched prebuilt board found in src/python/gem5/prebuilt/riscvmatched/
+
+Usage
+-----
+
+```
+scons build/RISCV/gem5.opt
+./build/RISCV/gem5.opt \
+    configs/example_RAPIDO24//riscv_demo_board_se.py \
+	--workload=/path/to/riscv/binary
+```
+"""
+
+from gem5.resources.resource import CustomResource
+from gem5.simulate.simulator import Simulator
+from gem5.prebuilt.riscvmatched.riscvmatched_board import RISCVMatchedBoard
+from gem5.components.boards.simple_board import SimpleBoard
+from gem5.components.memory import DualChannelDDR4_2400
+from gem5.components.processors.cpu_types import CPUTypes
+from gem5.components.processors.simple_core import SimpleCore
+from gem5.components.processors.simple_processor import SimpleProcessor
+from gem5.components.cachehierarchies.classic.private_l1_private_l2_cache_no_ptwc_hierarchy import (
+    PrivateL1PrivateL2CacheNoPTWCHierarchy,
+)
+from gem5.isas import ISA
+from gem5.utils.requires import requires
+
+
+
+requires(isa_required=ISA.RISCV)
+
+import argparse
+
+parser = argparse.ArgumentParser(
+    description="A script which uses the RISCVMatchedBoard in SE mode."
+)
+
+# Additional options
+parser.add_argument(
+    "--workload",
+    type=str,
+    required=True,
+    help="Path of the binary to run",
+)
+parser.add_argument(
+    "--options",
+    type=str,
+    help="Options of the binary",
+)
+parser.add_argument(
+    "--use-arch-pt",
+    action="store_true",
+    default=False,
+    help="Enable the use of page table in SE mode. Default: False",
+)
+parser.add_argument(
+    "--dtb-size",
+    type=int,
+    default=64,
+    help="Number of data TLB entries. Default: 64"
+)
+parser.add_argument(
+    "--itb-size",
+    type=int,
+    default=64,
+    help="Number of data TLB entries. Default: 64"
+)
+
+args = parser.parse_args()
+
+# Processor setup
+processor = SimpleProcessor(
+    cpu_type=CPUTypes.O3, isa=ISA.RISCV, num_cores=1
+)
+for core in processor.get_cores():
+    core.get_mmu().itb.size = args.itb_size
+    core.get_mmu().dtb.size = args.dtb_size
+
+# Cache setup
+cache_hierarchy = PrivateL1PrivateL2CacheNoPTWCHierarchy(
+    l1d_size="32kB", l1i_size="32kB", l2_size="256kB"
+)
+
+# Memory setup
+memory = DualChannelDDR4_2400(size="8GB")
+
+# instantiate the riscv board
+board = SimpleBoard(
+    clk_freq = '3GHz',
+    processor = processor,
+    memory = memory,
+    cache_hierarchy = cache_hierarchy
+)
+
+# set the riscv binary as the board workload
+arguments = [option for option in (args.options).split()] if args.options != None else []
+board.set_se_binary_workload(
+    binary=CustomResource(args.workload),
+    arguments=arguments,
+    use_arch_pt = args.use_arch_pt
+)
+
+# run the simulation with the RISCV board
+MAX_INSTS = 2 * 10**9
+simulator = Simulator(board=board, full_system=False)
+simulator.schedule_max_insts(MAX_INSTS)
+simulator.run()
+
+print(
+    "Exiting @ tick {} because {}.".format(
+        simulator.get_current_tick(),
+        simulator.get_last_exit_event_cause(),
+    )
+)
diff --git a/src/arch/riscv/pagetable.hh b/src/arch/riscv/pagetable.hh
index 06a054faa9..0213bba10e 100644
--- a/src/arch/riscv/pagetable.hh
+++ b/src/arch/riscv/pagetable.hh
@@ -31,10 +31,12 @@
 #ifndef __ARCH_RISCV_PAGETABLE_H__
 #define __ARCH_RISCV_PAGETABLE_H__
 
+#include "arch/riscv/page_size.hh"
 #include "base/bitunion.hh"
 #include "base/logging.hh"
 #include "base/trie.hh"
 #include "base/types.hh"
+#include "mem/port_proxy.hh"
 #include "sim/serialize.hh"
 
 namespace gem5
@@ -76,6 +78,82 @@ BitUnion64(PTESv39)
     Bitfield<0> v;
 EndBitUnion(PTESv39)
 
+template <int first, int last>
+class HierarchySv39
+{
+public:
+    Addr paddr()            { return pte.ppn << PageShift; }
+    void paddr(Addr addr)   { pte.ppn = addr >> PageShift; }
+
+    bool present()          { return pte.v; }
+    void present(bool p)    { pte.v = p ? 1 : 0; }
+
+    bool uncacheable()      { return true; }
+    void uncacheable(bool u){ }
+
+    bool readonly()         { return !pte.w; }
+    void readonly(bool r)   { pte.w = r ? 0 : 1; }
+
+    bool user()             { return pte.u; }
+    void user(bool u)       { pte.u = u ? 1 : 0; }
+
+    bool read()             { return pte.r; }
+    void read(bool r)       { pte.r = r ? 1 : 0; }
+    bool write()            { return pte.w; }
+    void write(bool w)      { pte.w = w ? 1 : 0; }
+    bool exec()             { return pte.x; }
+    void exec(bool x)       { pte.x = x ? 1 : 0; }
+
+    PTESv39 getPTE()        { return pte; }
+
+
+    void
+    read(PortProxy &p, Addr table, Addr vaddr)
+    {
+        entryAddr = table;
+        entryAddr += bits(vaddr, first, last) * sizeof(PTESv39);
+        pte = p.read<PTESv39>(entryAddr);
+    }
+
+    void
+    reset(Addr _paddr, bool _present=true, bool _executable=false,
+        bool _uncacheable=false, bool _readonly=false, bool _user=true, 
+        bool _is_leaf=false)
+    {
+        pte = 0;
+        paddr(_paddr);
+        present(_present);
+        uncacheable(_uncacheable);
+        readonly(_readonly);
+        user(_user);
+        if (_is_leaf) {
+            read(true);
+            write(true);
+            exec(_executable);
+        } else {
+            write(false);
+            read(false);
+            exec(false);
+        }
+    }
+
+    void
+    write(PortProxy &p)
+    {
+        p.write(entryAddr, pte);
+    }
+
+    static int
+    tableSize()
+    {
+        return 1 << ((first - last) + 4 - PageShift);
+    }
+
+protected:
+    PTESv39 pte;
+    Addr entryAddr;
+};
+
 struct TlbEntry;
 typedef Trie<Addr, TlbEntry> TlbEntryTrie;
 
diff --git a/src/arch/riscv/pagetable_walker.cc b/src/arch/riscv/pagetable_walker.cc
index cbd5bd2b22..3a44457399 100644
--- a/src/arch/riscv/pagetable_walker.cc
+++ b/src/arch/riscv/pagetable_walker.cc
@@ -308,6 +308,11 @@ Walker::WalkerState::stepWalk(PacketPtr &write)
     fault = walker->pmp->pmpCheck(read->req, BaseMMU::Read,
                     RiscvISA::PrivilegeMode::PRV_S, tc, entry.vaddr);
 
+    // Hack: Should be moved in elf_object
+    // if (level==0 and mode==BaseMMU::Execute) {
+    //     pte.x = 1;
+    // }
+
     if (fault == NoFault) {
         // step 3:
         if (!pte.v || (!pte.r && pte.w)) {
diff --git a/src/arch/riscv/process.cc b/src/arch/riscv/process.cc
index cd00f5d63a..2776e45830 100644
--- a/src/arch/riscv/process.cc
+++ b/src/arch/riscv/process.cc
@@ -55,33 +55,47 @@
 #include "sim/syscall_return.hh"
 #include "sim/system.hh"
 
+#include "arch/riscv/pagetable.hh"
+#include "mem/multi_level_page_table.hh"
+
 namespace gem5
 {
 
 using namespace RiscvISA;
 
+template class MultiLevelPageTable<HierarchySv39<38, 30>,
+                                   HierarchySv39<29, 21>,
+                                   HierarchySv39<20, 12> >;
+
+typedef MultiLevelPageTable<HierarchySv39<38, 30>,
+                            HierarchySv39<29, 21>,
+                            HierarchySv39<20, 12> > ArchPageTable;
+
 RiscvProcess::RiscvProcess(const ProcessParams &params,
         loader::ObjectFile *objFile) :
-        Process(params,
+        Process(params, params.useArchPT ?
+                static_cast<EmulationPageTable *>(
+                            new ArchPageTable(params.name, params.pid,
+                                              params.system, PageBytes)) :
                 new EmulationPageTable(params.name, params.pid, PageBytes),
                 objFile)
 {
-    fatal_if(params.useArchPT, "Arch page tables not implemented.");
 }
 
 RiscvProcess64::RiscvProcess64(const ProcessParams &params,
         loader::ObjectFile *objFile) :
         RiscvProcess(params, objFile)
 {
-    const Addr stack_base = 0x7FFFFFFFFFFFFFFFL;
+    const Addr stack_base = useArchPT ? 0xFFFF'FFFF'FFFF'0000L : 0x7FFFFFFFFFFFFFFFL;
     const Addr max_stack_size = 8 * 1024 * 1024;
     const Addr next_thread_stack_base = stack_base - max_stack_size;
     const Addr brk_point = roundUp(image.maxAddr(), PageBytes);
-    const Addr mmap_end = 0x4000000000000000L;
+    const Addr mmap_end = useArchPT ? 0xFFFF'FFEF'FFFF'0000L : 0x4000000000000000L;
     memState = std::make_shared<MemState>(this, brk_point, stack_base,
             max_stack_size, next_thread_stack_base, mmap_end);
 }
 
+
 RiscvProcess32::RiscvProcess32(const ProcessParams &params,
         loader::ObjectFile *objFile) :
         RiscvProcess(params, objFile)
@@ -98,8 +112,27 @@ RiscvProcess32::RiscvProcess32(const ProcessParams &params,
 void
 RiscvProcess64::initState()
 {
+    // Setup SATP register
+    SATP satp = 0x0;
+    if (useArchPT)
+    {
+        satp.mode = AddrXlateMode::SV39;
+        satp.asid = this->pid();
+        for (ContextID ctx: contextIds)
+            system->threads[ctx]->setMiscReg(MISCREG_SATP, satp);
+    }
+
     Process::initState();
 
+    // Setup SATP.PPN field
+    // This is done after pTable initialization
+    if (useArchPT)
+    {
+        satp.ppn = static_cast<ArchPageTable*>(pTable)->basePtr();
+        for (ContextID ctx: contextIds)
+            system->threads[ctx]->setMiscReg(MISCREG_SATP, satp);
+    }
+
     argsInit<uint64_t>(PageBytes);
     for (ContextID ctx: contextIds) {
         auto *tc = system->threads[ctx];
diff --git a/src/arch/riscv/tlb.cc b/src/arch/riscv/tlb.cc
index ac8c8ae029..e91d017172 100644
--- a/src/arch/riscv/tlb.cc
+++ b/src/arch/riscv/tlb.cc
@@ -256,20 +256,24 @@ TLB::checkPermissions(STATUS status, PrivilegeMode pmode, Addr vaddr,
 Fault
 TLB::createPagefault(Addr vaddr, BaseMMU::Mode mode)
 {
-    ExceptionCode code;
-    if (mode == BaseMMU::Read)
-        code = ExceptionCode::LOAD_PAGE;
-    else if (mode == BaseMMU::Write)
-        code = ExceptionCode::STORE_PAGE;
-    else
-        code = ExceptionCode::INST_PAGE;
-    return std::make_shared<AddressFault>(vaddr, code);
+    if (FullSystem) {
+        ExceptionCode code;
+        if (mode == BaseMMU::Read)
+            code = ExceptionCode::LOAD_PAGE;
+        else if (mode == BaseMMU::Write)
+            code = ExceptionCode::STORE_PAGE;
+        else
+            code = ExceptionCode::INST_PAGE;
+        return std::make_shared<AddressFault>(vaddr, code);
+    }
+    
+    return std::make_shared<GenericPageTableFault>(vaddr);
 }
 
 Addr
 TLB::translateWithTLB(Addr vaddr, uint16_t asid, BaseMMU::Mode mode)
 {
-    TlbEntry *e = lookup(vaddr, asid, mode, false);
+    TlbEntry *e = lookup(vaddr, asid, mode, true);
     assert(e != nullptr);
     return e->paddr << PageShift | (vaddr & mask(e->logBytes));
 }
@@ -292,7 +296,7 @@ TLB::doTranslate(const RequestPtr &req, ThreadContext *tc,
             delayed = true;
             return fault;
         }
-        e = lookup(vaddr, satp.asid, mode, false);
+        e = lookup(vaddr, satp.asid, mode, true);
         assert(e != nullptr);
     }
 
@@ -339,7 +343,7 @@ TLB::translate(const RequestPtr &req, ThreadContext *tc,
 {
     delayed = false;
 
-    if (FullSystem) {
+    if (FullSystem || tc->getProcessPtr()->useArchPT) {
         PrivilegeMode pmode = getMemPriv(tc, mode);
         SATP satp = tc->readMiscReg(MISCREG_SATP);
         if (pmode == PrivilegeMode::PRV_M || satp.mode == AddrXlateMode::BARE)
@@ -360,14 +364,7 @@ TLB::translate(const RequestPtr &req, ThreadContext *tc,
         // an illegal address exception.
         // TODO where is that written in the manual?
         if (!delayed && fault == NoFault && bits(req->getPaddr(), 63)) {
-            ExceptionCode code;
-            if (mode == BaseMMU::Read)
-                code = ExceptionCode::LOAD_ACCESS;
-            else if (mode == BaseMMU::Write)
-                code = ExceptionCode::STORE_ACCESS;
-            else
-                code = ExceptionCode::INST_ACCESS;
-            fault = std::make_shared<AddressFault>(req->getVaddr(), code);
+            createPagefault(req->getVaddr(), mode);
         }
 
         if (!delayed && fault == NoFault) {
@@ -430,13 +427,14 @@ TLB::translateFunctional(const RequestPtr &req, ThreadContext *tc,
     const Addr vaddr = req->getVaddr();
     Addr paddr = vaddr;
 
-    if (FullSystem) {
+    if (FullSystem || tc->getProcessPtr()->useArchPT) {
         MMU *mmu = static_cast<MMU *>(tc->getMMUPtr());
 
         PrivilegeMode pmode = mmu->getMemPriv(tc, mode);
         SATP satp = tc->readMiscReg(MISCREG_SATP);
-        if (pmode != PrivilegeMode::PRV_M &&
-            satp.mode != AddrXlateMode::BARE) {
+        if ((pmode != PrivilegeMode::PRV_M &&
+            satp.mode != AddrXlateMode::BARE) ||
+            tc->getProcessPtr()->useArchPT) {
             Walker *walker = mmu->getDataWalker();
             unsigned logBytes;
             Fault fault = walker->startFunctional(
@@ -530,7 +528,10 @@ TLB::TlbStats::TlbStats(statistics::Group *parent)
              "Total TLB (read and write) misses", readMisses + writeMisses),
     ADD_STAT(accesses, statistics::units::Count::get(),
              "Total TLB (read and write) accesses",
-             readAccesses + writeAccesses)
+             readAccesses + writeAccesses),
+    ADD_STAT(missRate, statistics::units::Count::get(),
+             "TLB missrate (read and write)",
+             misses / accesses)
 {
 }
 
diff --git a/src/arch/riscv/tlb.hh b/src/arch/riscv/tlb.hh
index f37143dfb7..8c2e919975 100644
--- a/src/arch/riscv/tlb.hh
+++ b/src/arch/riscv/tlb.hh
@@ -83,6 +83,7 @@ class TLB : public BaseTLB
         statistics::Formula hits;
         statistics::Formula misses;
         statistics::Formula accesses;
+        statistics::Formula missRate;
     } stats;
 
   public:
diff --git a/src/base/loader/elf_object.cc b/src/base/loader/elf_object.cc
index 4b1467acf0..1415d9fddd 100644
--- a/src/base/loader/elf_object.cc
+++ b/src/base/loader/elf_object.cc
@@ -350,13 +350,15 @@ ElfObject::handleLoadableSegment(GElf_Phdr phdr, int seg_num)
 {
     auto name = std::to_string(seg_num);
 
+    bool executable = phdr.p_flags & PF_X;
+
     if (phdr.p_memsz == 0) {
         warn("Ignoring empty loadable segment %s", name);
         return;
     }
 
     image.addSegment({ name, phdr.p_paddr, imageData,
-                       phdr.p_offset, phdr.p_filesz });
+                       phdr.p_offset, phdr.p_filesz, executable});
     Addr uninitialized = phdr.p_memsz - phdr.p_filesz;
     if (uninitialized) {
         // There may be parts of a segment which aren't included in the
diff --git a/src/base/loader/memory_image.cc b/src/base/loader/memory_image.cc
index a3f378c10b..38f349dc2e 100644
--- a/src/base/loader/memory_image.cc
+++ b/src/base/loader/memory_image.cc
@@ -40,7 +40,7 @@ MemoryImage::writeSegment(const Segment &seg, const PortProxy &proxy) const
 {
     if (seg.size != 0) {
         if (seg.data) {
-            proxy.writeBlob(seg.base, seg.data, seg.size);
+            proxy.writeBlob(seg.base, seg.data, seg.size, seg.executable);            
         } else {
             // no image: must be bss
             proxy.memsetBlob(seg.base, 0, seg.size);
diff --git a/src/base/loader/memory_image.hh b/src/base/loader/memory_image.hh
index 1207e7458d..24612527ba 100644
--- a/src/base/loader/memory_image.hh
+++ b/src/base/loader/memory_image.hh
@@ -55,17 +55,17 @@ class MemoryImage
     struct Segment
     {
         Segment(const std::string &_name, Addr _base,
-                const uint8_t *_data, size_t _size) :
-            name(_name), base(_base), data(_data), size(_size)
+                const uint8_t *_data, size_t _size, bool _exec=false) :
+            name(_name), base(_base), data(_data), size(_size), executable(_exec)
         {}
 
-        Segment(const std::string &_name, Addr _base, size_t _size) :
-            name(_name), base(_base), size(_size)
+        Segment(const std::string &_name, Addr _base, size_t _size, bool _exec=false) :
+            name(_name), base(_base), size(_size), executable(_exec)
         {}
 
         Segment(const std::string &_name, Addr _base,
-                const ImageFileDataPtr &_ifd, Addr offset, size_t _size) :
-            ifd(_ifd), name(_name), base(_base), size(_size)
+                const ImageFileDataPtr &_ifd, Addr offset, size_t _size, bool _exec=false) :
+            ifd(_ifd), name(_name), base(_base), size(_size), executable(_exec)
         {
             panic_if(offset + size > ifd->len(),
                     "Segment outside the bounds of the image data");
@@ -81,6 +81,7 @@ class MemoryImage
         Addr base = 0;
         const uint8_t *data = nullptr;
         size_t size = 0;
+        bool executable;
     };
 
     MemoryImage() {}
diff --git a/src/mem/multi_level_page_table.hh b/src/mem/multi_level_page_table.hh
index f482f8cba4..01696d42ae 100644
--- a/src/mem/multi_level_page_table.hh
+++ b/src/mem/multi_level_page_table.hh
@@ -217,7 +217,7 @@ public:
     Addr basePtr() { return _basePtr; }
 
     void
-    map(Addr vaddr, Addr paddr, int64_t size, uint64_t flags = 0) override
+    map(Addr vaddr, Addr paddr, int64_t size, uint64_t flags = 0, bool executable=false) override
     {
         EmulationPageTable::map(vaddr, paddr, size, flags);
 
@@ -226,9 +226,8 @@ public:
         for (int64_t offset = 0; offset < size; offset += _pageSize) {
             walk<EntryTypes...>(system, _pageSize, _basePtr,
                                 vaddr + offset, true, &entry);
-
-            entry.reset(paddr + offset, true, flags & Uncacheable,
-                        flags & ReadOnly);
+            entry.reset(paddr + offset, true, executable, flags & Uncacheable,
+                        flags & ReadOnly, true, true);
             entry.write(system->physProxy);
 
             DPRINTF(MMU, "New mapping: %#x-%#x\n",
diff --git a/src/mem/page_table.cc b/src/mem/page_table.cc
index d715e0771f..5af0698994 100644
--- a/src/mem/page_table.cc
+++ b/src/mem/page_table.cc
@@ -45,7 +45,7 @@ namespace gem5
 {
 
 void
-EmulationPageTable::map(Addr vaddr, Addr paddr, int64_t size, uint64_t flags)
+EmulationPageTable::map(Addr vaddr, Addr paddr, int64_t size, uint64_t flags, bool executable)
 {
     bool clobber = flags & Clobber;
     // starting address must be page aligned
diff --git a/src/mem/page_table.hh b/src/mem/page_table.hh
index a17250c17d..364187df80 100644
--- a/src/mem/page_table.hh
+++ b/src/mem/page_table.hh
@@ -122,7 +122,7 @@ class EmulationPageTable : public Serializable
      * @param flags Generic mapping flags that can be set by or-ing values
      *              from MappingFlags enum.
      */
-    virtual void map(Addr vaddr, Addr paddr, int64_t size, uint64_t flags = 0);
+    virtual void map(Addr vaddr, Addr paddr, int64_t size, uint64_t flags = 0, bool executable=false);
     virtual void remap(Addr vaddr, int64_t size, Addr new_vaddr);
     virtual void unmap(Addr vaddr, int64_t size);
 
diff --git a/src/mem/port_proxy.hh b/src/mem/port_proxy.hh
index 29f6ba60a4..ac68ae01cf 100644
--- a/src/mem/port_proxy.hh
+++ b/src/mem/port_proxy.hh
@@ -154,7 +154,7 @@ class PortProxy : FunctionalRequestProtocol
      * Returns true on success and false on failure.
      */
     virtual bool
-    tryWriteBlob(Addr addr, const void *p, int size) const
+    tryWriteBlob(Addr addr, const void *p, int size, bool executable=false) const
     {
         writeBlobPhys(addr, 0, p, size);
         return true;
@@ -189,9 +189,9 @@ class PortProxy : FunctionalRequestProtocol
      * Same as tryWriteBlob, but insists on success.
      */
     void
-    writeBlob(Addr addr, const void *p, int size) const
+    writeBlob(Addr addr, const void *p, int size, bool executable=false) const
     {
-        if (!tryWriteBlob(addr, p, size))
+        if (!tryWriteBlob(addr, p, size, executable))
             fatal("writeBlob(%#x, ...) failed", addr);
     }
 
diff --git a/src/mem/se_translating_port_proxy.cc b/src/mem/se_translating_port_proxy.cc
index 8f4544c80f..b7aebfe70a 100644
--- a/src/mem/se_translating_port_proxy.cc
+++ b/src/mem/se_translating_port_proxy.cc
@@ -57,9 +57,15 @@ SETranslatingPortProxy::fixupRange(const TranslationGen::Range &range,
 {
     auto *process = _tc->getProcessPtr();
 
-    if (mode == BaseMMU::Write) {
+    if (mode == BaseMMU::Write || mode == BaseMMU::Execute) {
         if (allocating == Always) {
-            process->allocateMem(range.vaddr, range.size);
+            if (mode == BaseMMU::Write) {
+                process->allocateMem(range.vaddr, range.size);
+            }
+            else{
+                process->allocateMem(range.vaddr, range.size, false,true);
+            }
+            
             return true;
         } else if (allocating == NextPage &&
                 process->fixupFault(range.vaddr)) {
diff --git a/src/mem/translating_port_proxy.cc b/src/mem/translating_port_proxy.cc
index 8ab859f40d..9efeca4453 100644
--- a/src/mem/translating_port_proxy.cc
+++ b/src/mem/translating_port_proxy.cc
@@ -98,10 +98,10 @@ TranslatingPortProxy::tryReadBlob(Addr addr, void *p, int size) const
 }
 
 bool
-TranslatingPortProxy::tryWriteBlob(
-        Addr addr, const void *p, int size) const
+TranslatingPortProxy::tryWriteBlob(Addr addr, const void *p, int size, 
+            bool executable) const
 {
-    constexpr auto mode = BaseMMU::Write;
+    auto mode = executable ? BaseMMU::Execute : BaseMMU::Write;
     return tryOnBlob(mode, _tc->getMMUPtr()->translateFunctional(
             addr, size, _tc, mode, flags),
         [this, &p](const auto &range) {
diff --git a/src/mem/translating_port_proxy.hh b/src/mem/translating_port_proxy.hh
index bedb57a3ce..4ef9a4e0cf 100644
--- a/src/mem/translating_port_proxy.hh
+++ b/src/mem/translating_port_proxy.hh
@@ -81,7 +81,8 @@ class TranslatingPortProxy : public PortProxy
 
     /** Version of tryWriteBlob that translates virt->phys and deals
       * with page boundries. */
-    bool tryWriteBlob(Addr addr, const void *p, int size) const override;
+    bool tryWriteBlob(Addr addr, const void *p, int size, 
+            bool executable=false) const override;
 
     /**
      * Fill size bytes starting at addr with byte value val.
diff --git a/src/python/SConscript b/src/python/SConscript
index ea9d3d4021..d5e0159cf8 100644
--- a/src/python/SConscript
+++ b/src/python/SConscript
@@ -91,6 +91,9 @@ PySource('gem5.components.cachehierarchies.classic',
 PySource('gem5.components.cachehierarchies.classic',
     'gem5/components/cachehierarchies/classic/'
     'private_l1_private_l2_cache_hierarchy.py')
+PySource('gem5.components.cachehierarchies.classic',
+    'gem5/components/cachehierarchies/classic/'
+    'private_l1_private_l2_cache_no_ptwc_hierarchy.py')
 PySource('gem5.components.cachehierarchies.classic',
     'gem5/components/cachehierarchies/classic/'
     'private_l1_shared_l2_cache_hierarchy.py')
diff --git a/src/python/gem5/components/boards/se_binary_workload.py b/src/python/gem5/components/boards/se_binary_workload.py
index c62a1b67ea..d19bc3a908 100644
--- a/src/python/gem5/components/boards/se_binary_workload.py
+++ b/src/python/gem5/components/boards/se_binary_workload.py
@@ -71,6 +71,7 @@ class SEBinaryWorkload:
         env_list: Optional[List[str]] = None,
         arguments: List[str] = [],
         checkpoint: Optional[Union[Path, CheckpointResource]] = None,
+        use_arch_pt: bool = False,
     ) -> None:
         """Set up the system to run a specific binary.
 
@@ -89,6 +90,7 @@ class SEBinaryWorkload:
         :param arguments: The input arguments for the binary
         :param checkpoint: The checkpoint directory. Used to restore the
         simulation to that checkpoint.
+        :param use_arch_pt: Enable the use of page walker in SE mode.
         """
 
         # We assume this this is in a multiple-inheritance setup with an
@@ -113,6 +115,7 @@ class SEBinaryWorkload:
             process.errout = stderr_file.as_posix()
         if env_list is not None:
             process.env = env_list
+        process.useArchPT = use_arch_pt
 
         if isinstance(self.get_processor(), SwitchableProcessor):
             # This is a hack to get switchable processors working correctly in
diff --git a/src/python/gem5/components/cachehierarchies/classic/private_l1_private_l2_cache_no_ptwc_hierarchy.py b/src/python/gem5/components/cachehierarchies/classic/private_l1_private_l2_cache_no_ptwc_hierarchy.py
new file mode 100644
index 0000000000..6ebb2f7b1b
--- /dev/null
+++ b/src/python/gem5/components/cachehierarchies/classic/private_l1_private_l2_cache_no_ptwc_hierarchy.py
@@ -0,0 +1,177 @@
+# Copyright (c) 2021 The Regents of the University of California
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+from ..abstract_cache_hierarchy import AbstractCacheHierarchy
+from .abstract_classic_cache_hierarchy import AbstractClassicCacheHierarchy
+from ..abstract_two_level_cache_hierarchy import AbstractTwoLevelCacheHierarchy
+from .caches.l1dcache import L1DCache
+from .caches.l1icache import L1ICache
+from .caches.l2cache import L2Cache
+from .caches.mmu_cache import MMUCache
+from ...boards.abstract_board import AbstractBoard
+from ....isas import ISA
+from m5.objects import Cache, L2XBar, BaseXBar, SystemXBar, BadAddr, Port
+
+from ....utils.override import *
+
+
+class PrivateL1PrivateL2CacheNoPTWCHierarchy(
+    AbstractClassicCacheHierarchy, AbstractTwoLevelCacheHierarchy
+):
+    """
+    A cache setup where each core has a private L1 Data and Instruction Cache,
+    and a private L2 cache.
+    """
+
+    @staticmethod
+    def _get_default_membus() -> SystemXBar:
+        """
+        A method used to obtain the default memory bus of 64 bit in width for
+        the PrivateL1PrivateL2 CacheHierarchy.
+
+        :returns: The default memory bus for the PrivateL1PrivateL2
+        CacheHierarchy.
+
+        :rtype: SystemXBar
+        """
+        membus = SystemXBar(width=64)
+        membus.badaddr_responder = BadAddr()
+        membus.default = membus.badaddr_responder.pio
+        return membus
+
+    def __init__(
+        self,
+        l1d_size: str,
+        l1i_size: str,
+        l2_size: str,
+        membus: BaseXBar = _get_default_membus.__func__(),
+    ) -> None:
+        """
+        :param l1d_size: The size of the L1 Data Cache (e.g., "32kB").
+
+        :type l1d_size: str
+
+        :param  l1i_size: The size of the L1 Instruction Cache (e.g., "32kB").
+
+        :type l1i_size: str
+
+        :param l2_size: The size of the L2 Cache (e.g., "256kB").
+
+        :type l2_size: str
+
+        :param membus: The memory bus. This parameter is optional parameter and
+        will default to a 64 bit width SystemXBar is not specified.
+
+        :type membus: BaseXBar
+        """
+
+        AbstractClassicCacheHierarchy.__init__(self=self)
+        AbstractTwoLevelCacheHierarchy.__init__(
+            self,
+            l1i_size=l1i_size,
+            l1i_assoc=8,
+            l1d_size=l1d_size,
+            l1d_assoc=8,
+            l2_size=l2_size,
+            l2_assoc=4,
+        )
+
+        self.membus = membus
+
+    @overrides(AbstractClassicCacheHierarchy)
+    def get_mem_side_port(self) -> Port:
+        return self.membus.mem_side_ports
+
+    @overrides(AbstractClassicCacheHierarchy)
+    def get_cpu_side_port(self) -> Port:
+        return self.membus.cpu_side_ports
+
+    @overrides(AbstractCacheHierarchy)
+    def incorporate_cache(self, board: AbstractBoard) -> None:
+
+        # Set up the system port for functional access from the simulator.
+        board.connect_system_port(self.membus.cpu_side_ports)
+
+        for _, port in board.get_memory().get_mem_ports():
+            self.membus.mem_side_ports = port
+
+        self.l1icaches = [
+            L1ICache(size=self._l1i_size)
+            for i in range(board.get_processor().get_num_cores())
+        ]
+        self.l1dcaches = [
+            L1DCache(size=self._l1d_size)
+            for i in range(board.get_processor().get_num_cores())
+        ]
+        self.l2buses = [
+            L2XBar() for i in range(board.get_processor().get_num_cores())
+        ]
+        self.l2caches = [
+            L2Cache(size=self._l2_size)
+            for i in range(board.get_processor().get_num_cores())
+        ]
+
+        if board.has_coherent_io():
+            self._setup_io_cache(board)
+
+        for i, cpu in enumerate(board.get_processor().get_cores()):
+
+            cpu.connect_icache(self.l1icaches[i].cpu_side)
+            cpu.connect_dcache(self.l1dcaches[i].cpu_side)
+
+            self.l1icaches[i].mem_side = self.l2buses[i].cpu_side_ports
+            self.l1dcaches[i].mem_side = self.l2buses[i].cpu_side_ports
+
+            self.l2buses[i].mem_side_ports = self.l2caches[i].cpu_side
+
+            self.membus.cpu_side_ports = self.l2caches[i].mem_side
+
+            cpu.connect_walker_ports(
+                self.l2buses[i].cpu_side_ports,
+                self.l2buses[i].cpu_side_ports
+            )
+
+            if board.get_processor().get_isa() == ISA.X86:
+                int_req_port = self.membus.mem_side_ports
+                int_resp_port = self.membus.cpu_side_ports
+                cpu.connect_interrupt(int_req_port, int_resp_port)
+            else:
+                cpu.connect_interrupt()
+
+    def _setup_io_cache(self, board: AbstractBoard) -> None:
+        """Create a cache for coherent I/O connections"""
+        self.iocache = Cache(
+            assoc=8,
+            tag_latency=50,
+            data_latency=50,
+            response_latency=50,
+            mshrs=20,
+            size="1kB",
+            tgts_per_mshr=12,
+            addr_ranges=board.mem_ranges,
+        )
+        self.iocache.mem_side = self.membus.cpu_side_ports
+        self.iocache.cpu_side = board.get_mem_side_coherent_io_port()
diff --git a/src/sim/process.cc b/src/sim/process.cc
index a348b450b0..6619fb92ba 100644
--- a/src/sim/process.cc
+++ b/src/sim/process.cc
@@ -314,7 +314,7 @@ Process::drain()
 }
 
 void
-Process::allocateMem(Addr vaddr, int64_t size, bool clobber)
+Process::allocateMem(Addr vaddr, int64_t size, bool clobber, bool executable)
 {
     const auto page_size = pTable->pageSize();
 
@@ -340,7 +340,7 @@ Process::allocateMem(Addr vaddr, int64_t size, bool clobber)
     const Addr pages_size = npages * page_size;
     pTable->map(page_addr, paddr, pages_size,
                 clobber ? EmulationPageTable::Clobber :
-                          EmulationPageTable::MappingFlags(0));
+                          EmulationPageTable::MappingFlags(0), executable);
 }
 
 void
diff --git a/src/sim/process.hh b/src/sim/process.hh
index d6d30cebc8..b953114e2a 100644
--- a/src/sim/process.hh
+++ b/src/sim/process.hh
@@ -118,7 +118,7 @@ class Process : public SimObject
     // align to page boundaries, it will be expanded in either direction until
     // it does. This function will therefore set up *at least* the range
     // requested, and may configure more if necessary.
-    void allocateMem(Addr vaddr, int64_t size, bool clobber=false);
+    void allocateMem(Addr vaddr, int64_t size, bool clobber=false, bool executable=false);
 
     /// Attempt to fix up a fault at vaddr by allocating a page on the stack.
     /// @return Whether the fault has been fixed.
-- 
2.25.1

